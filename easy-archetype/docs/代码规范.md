# 代码规范

##  命名规范
1. 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO 等
2. 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。
3. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
4. 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。
5. POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。

## 各层命名规约：
### Service/DAO 层方法命名规约
1.  获取单个对象的方法用 get 做前缀。
2.  获取多个对象的方法用 list 做前缀。
3.  获取统计值的方法用 count 做前缀。
4.  插入的方法用 save（推荐）或 insert 做前缀。
5.  删除的方法用 remove（推荐）或 delete 做前缀。
6.  修改的方法用 update 做前缀。

### 领域模型命名规约
1.  数据对象：xxxDO，xxx 即为数据表名。
2.  数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
3.  展示对象：xxxVO，xxx 一般为网页名称。 
4.  POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

## 常量定义
1. 不允许出现任何魔法值（即未经定义的常量）直接出现在代码中
2. long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。
3. 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。
> 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护
4. 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。
   1. 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下
   2. 应用内共享常量：放置在一方库的 modules 中的 constant 目录下
   3. 子工程内部共享常量：即在当前子工程的 constant 目录下。
   4. 包内共享常量：即在当前包下单独的 constant 目录下
   5. 类内共享常量：直接在类内部 private static final 定义。
   

## OOP规范
1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。
2. 【强制】所有的覆写方法，必须加@Override 注解。
3. 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。
4.  【强制】对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。
5. 【强制】不能使用过时的类或方法。
  > 说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应
   该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，
   那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么
6. 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。
 > 正例： "test".equals(object);
   反例： object.equals("test");
   说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类）
7. 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较
8.  【强制】关于基本数据类型与包装数据类型的使用标准如下：
    1. 所有的 POJO 类属性必须使用包装数据类型。
    2.  RPC 方法的返回值和参数必须使用包装数据类型。
    3. 所有的局部变量【推荐】使用基本数据类型。

## 注释规范
1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用//xxx 方式。
2. 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。
3. 所有的类都必须添加创建者信息
4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。
5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途

## 异常处理
1. 【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。
2. 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。
3. 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理
4. 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
5. 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。
6.  【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。
7. 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。
8. 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
    1. 返回类型为包装数据类型，有可能是 null，返回 int 值时注意判空。
    2. 数据库的查询结果可能为 null。
    3. 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
    4. 远程调用返回对象，一律要求进行 NPE 判断
    5. 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。
    6. 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE
9. 在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess、“错误码”、“错误简短信息”。
10.  【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。

## 日志规范
1. 应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。
2.  【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。
3. 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
4.  【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。
   > 正例：<logger name="com.taobao.dubbo.config" additivity="false">
5.  【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。

## 应用分层
1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推：
     开放接口层   -     web层
        [  业务处理Servcie层   ]
         ⬆    通用处理Manage层
      数据持久化Dao层     ⬆
      数据源         外部第三方接口
   - 开放接口层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。
   - Web 层：各个端的模板渲染并执行显示层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示层等。
   - Service 层：相对具体的业务逻辑服务层。
   - Manager 层：通用业务处理层，它有如下特征：
      1. 对第三方平台封装的层，预处理返回结果及转化异常信息；
      2. 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；
      3. 与 DAO 层交互，对 DAO 的业务通用能力的封装
   - DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。
   - 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。
   
 
